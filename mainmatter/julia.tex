\appendix
\chapter{Brief introduction to Julia}%
\label{cha:a_very_short_introduction_to_julia}

In this chapter,
we very briefly present  some of the basic features and commands of Julia.
Most of the information contained in this chapter can be found in the online manual:
see the following links for documentation on
\href{https://docs.julialang.org/en/v1/stdlib/Pkg/}{packages},
\href{https://docs.julialang.org/en/v1/manual/control-flow/} {ifs and loops},
\href{https://docs.julialang.org/en/v1/manual/functions/} {functions},
\href{https://docs.juliaplots.org/latest/tutorial/} {plots},
\href{https://docs.julialang.org/en/v1/manual/variables-and-scoping/#man-scope-table} {scopes},
\href{https://docs.julialang.org/en/v1/manual/arrays/} {multi-dimensional arrays}.

\subsection*{Installing Julia}%
\label{sub:installing_julia}
The suggested programming environment for this course is the open-source text editor Visual Studio Code.
You may also use \emph{Vim} or \emph{Emacs},
if you are familiar with any of these.

\begin{task}
    Install Visual Studio Code.
    Install also the Julia and Jupyter Notebook extensions.
\end{task}

\subsection*{Obtaining documentation}%
\label{sub:getting_documentation}

To find documentation on a function from the Julia shell,
type ``\texttt{?}'' and then the name of the function.
Tab completion is helpful for listing available function names.

\begin{task}
    Read the help pages for \julia{if}, \julia{while} and \julia{for}.
\end{task}

\begin{remark}
    [Shorthand \julia{if} notation]
If there is no \julia{elseif} clause,
it is sometimes convenient to use the following shorthand notations instead of an \julia{if} block.
\begin{minted}{julia}
condition = true

# Assign 0 to x if `condition' is true, else assign 2
x = condition ? 0 : 2

# Print "true" if `condition' is true
condition && println("true")

# Print "false" if `condition' is false
condition || println("false")
\end{minted}
\end{remark}

\subsection*{Installing and using a package}%
\label{sub:installing_and_using_a_package}
To install a package for the Julia REPL (Read Evaluate Print Loop, also more simply called the Julia shell),
first type ``\texttt{]}'' to enter the package REPL,
and then type \julia{add} followed the name of the package to install.
For example, to use the \julia{Plots} package, write
\begin{minted}{julia}
import Plots
\end{minted}
in your the Julia shell or in a script.
If a function, say \julia{plot}, is defined by the package,
it can be accessed as \julia{Plots.plot}.

Alternatively, you may import the package with the \julia{using} keyword,
and then functions can be accessed without specifying the package name.
While convenient, this approach is less descriptive;
it does not explicitly show what package a function comes from.
For this reason, it is often recommended to use \julia{import},
especially in a large codebase.

\begin{task}
    Install the \texttt{Plots} package,
    read the documentation of the \texttt{Plots.plot} function,
    and to plot the function $f(x) = \sin(x)$.
    The tutorial on plotting, linked at the beginning of the chapter,
    is useful for this exercise.
\end{task}

\subsection*{Printing output}%
The functions \julia{println} or \julia{print} enable to display output.
The former adds a new line at the end and the latter does not.


\subsection*{Defining functions}%
\label{sub:defining_functions}
Functions can be defined using a \julia{function} block.
For example, the following code block defines a function that prints ``Hello, NAME!''.

\begin{minted}{julia}
function hello(name)
    # Here * is the string concatenation operator
    println("Hello, " * name)
end

# Call the function
hello("Bob")
\end{minted}

If the function definition is short,
it may be convenient to define it using the following more compact syntax:
\begin{minted}{julia}
hello(name) = println("Hello, " * name)
\end{minted}

Sometimes, it is useful to define a function without giving it a name, called an \emph{anonymous function}.
This can be achieved in Julia using the arrow notation \julia{->}.
For example, the following lines calculates the squares and cubes of the first 5 natural numbers.
Here, the function \julia{map} enables to transform a collection by applying a function to each element.
\begin{minted}{julia}
squares = map(x -> x^2, [1, 2, 3, 4, 5])
cubes = map(x -> x^3, [1, 2, 3, 4, 5])
\end{minted}

\begin{task}
    [Tower of Hanoi]
    We consider a variation on the popular Tower of Hanoi problem
    where the number $r$ of pegs is allowed to be larger than 3.
    We denote the pegs by $p_1, \dots, p_r$,
    and assume that the problem includes $n$ disks with radii $1$ to $n$.
    The tower is initially constructed in~$p_1$,
    with the disks arranged in order of decreasing radius, the largest at the bottom.
    The goal of the problem is to reconstruct the tower at $p_r$ by moving the disks one at the time,
    with the constraint that a disk may be placed on top of another only if its radius is smaller.

    It has been conjectured that the optimal solution,
    which requires the minimum number of moves,
    can always be decomposed into the following three steps:
    \begin{itemize}
        \item First move the top $k$ disks of the tower to peg $p_2$;
        \item Then move the bottom $n-k$ disks of the tower to $p_r$ without using $p_2$;
        \item Finally, move the top of the tower for $p_2$ to $p_r$.
    \end{itemize}
    This suggests a natural recursive procedure for solving the problem, known as the Frame-Steward algorithm.
    Write a Julia function \julia{T(n, r)} returning the minimal number of moves necessary.
\begin{minted}{julia}
function T(n, r)
    # Particular case
    if n == 1
        return 1
    end
    # Your code comes here
end
\end{minted}

\end{task}

\subsection*{Local and global scopes}%
Some constructs in Julia introduce scope blocks, notably \julia{for} and \julia{while} loops,
as well as \julia{function} blocks.
The variables defined within these structures are not available outside them.
For example
\begin{minted}{julia}
if true
    a = 1
end
println(a)
\end{minted}
prints one,
because \julia{if} does not introduce a scope block,
but
\begin{minted}{julia}
for i in [1, 2, 3]
    a = 1
end
println(a)
\end{minted}
produces \julia{ERROR: LoadError: UndefVarError: a not defined}.
The variable \julia{a} defined the \julia{for} loop is said to be in the \emph{local scope} of the loop,
whereas a variable defined outside of it is in the \emph{global scope}.
In order to modify a global variable from a local scope,
the \julia{global} keyword must be used.
For instance, the following code
\begin{minted}{julia}
a = 1
for i in [1, 2, 3]
    global a += 1
end
println(a)
\end{minted}
modifies the global variable \julia{a} and prints 4.
A more detailed discussion is beyond the scope of this course,
and we refer to Julia manual for additional documentation.

\subsection*{Multi-dimensional arrays}%
\label{sub:multi_dimensional_arrays}

A working knowledge of multi-dimensional arrays is important for this course,
as vectors and matrices are ubiquitous in numerical algorithms.

